#!/usr/bin/env ruby

require 'date'
require 'pathname'
require 'fileutils'

def load_gem_lib(lib_name)
  begin
    require lib_name
  rescue LoadError
    puts "You do not have the `#{lib_name}` gem installed"
    puts ""
    puts "Install with: gem install #{lib_name}"
    puts ""
    puts "You may be required to use sudo to install"
    exit(1)
  end
end

load_gem_lib('liquid')
load_gem_lib('rdiscount')

class Episode < Liquid::Drop

  def initialize(headers, body)
    @body = body

    @number, @title, @subtitle, @date, @guid, @length, @duration =
      headers.values_at(:number, :title, :subtitle, :date, :guid, :audio_file_size, :audio_duration)
  end

  attr_reader :number, :title, :subtitle, :guid, :length, :duration

  def pretty_date
    # Zero-padded day, full month name, year with century.
    @date.strftime("%-d %B %Y")
  end

  def itunes_date
    # Thu, 14 Jul 2016 12:00:00 GMT
    @date.strftime("%a, %-d %b %Y %H:%M:%S %z")
  end

  def rendered_body
    RDiscount.new(@body).to_html
  end

  def to_liquid
    self
  end

  def mp3_path
    "/audio/#{padded_episode_number}.mp3"
  end

  def episode_path
    "/episodes/#{padded_episode_number}.html"
  end

  def length_megabytes
    (@length.to_f / 1024**2).ceil
  end

  private

  def padded_episode_number
    "%05d" % @number
  end
end

def load_episodes(episode_parent_dir)
  paths = episode_parent_dir.entries.select{|path| path.to_s[/^\d+$/] }
  paths.map{|path| parse_episode(episode_parent_dir.join(path))}
end

def parse_episode(path)
  raw = File.read(path.join("#{path.basename}.md"))
  _, raw_headers, raw_body = raw.split(/^---$/)

  headers = parse_headers(raw_headers)
  body    = remove_leading_newlines(raw_body)
  Episode.new(headers, body)
end

def parse_headers(raw)
  headers = {}
  lines = remove_leading_newlines(raw).split("\n")

  lines.each do |line|
    key, value = line.split(/:\s+/)
    headers[key.to_sym] = value
  end

  # Parse the date to a DateTime object.
  headers[:date] = DateTime.parse(headers[:date])

  headers
end

def remove_leading_newlines(str)
  str.sub(/\A\n+/, '')
end

def render_template(filename, context)
  template     = Liquid::Template.parse(File.read("templates/#{filename}.liquid"), :error_mode => :strict)

  # Turn any non-string keys into string keys.
  stringified_context = {}
  context.each do |key, value|
    stringified_context[key.to_s] = value
  end

  # Make sure every template has access to config.
  stringified_context['config'] = load_config

  template.render!(stringified_context,  { strict_variables: true })
end

def write_file(filename, content)
  File.open("build/#{filename}", 'w+') do |f|
    f.write content
  end
end

def load_config
  YAML.load(File.read('config/website.yml'))
end

def load_secrets
  YAML.load(File.read('config/secrets.yml'))
end

def render_index(episodes)
  content = render_template("index.html", episodes: episodes)

  write_file('index.html', content)
end

def render_rss(episodes)
  content = render_template("rss.xml", episodes: episodes, secrets: load_secrets)

  write_file('rss.xml', content)
end

def copy_assets
  FileUtils.rm_rf('build/assets')
  FileUtils.cp_r('assets', 'build/assets')
end

episode_parent_dir = Pathname.new('episodes')
episodes = load_episodes(episode_parent_dir)
render_index(episodes)
render_rss(episodes)
copy_assets