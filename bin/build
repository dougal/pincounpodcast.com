#!/usr/bin/env ruby

require 'date'
require 'pathname'
require 'fileutils'

def load_gem_lib(lib_name)
  begin
    require lib_name
  rescue LoadError
    puts "You do not have the `#{lib_name}` gem installed"
    puts ""
    puts "Install with: gem install #{lib_name}"
    puts ""
    puts "You may be required to use sudo to install"
    exit(1)
  end
end

load_gem_lib('liquid')
load_gem_lib('rdiscount')

class Episode < Liquid::Drop

  def initialize(headers, body)
    @body = body

    @number, @title, @subtitle, @date, @guid, @length, @duration =
      headers.values_at(:number, :title, :subtitle, :date, :guid, :audio_file_size, :audio_duration)
  end

  attr_reader :number, :title, :subtitle, :guid, :length, :duration

  def pretty_date
    # Zero-padded day, full month name, year with century.
    @date.strftime("%-d %B %Y")
  end

  def itunes_date
    # Thu, 14 Jul 2016 12:00:00 GMT
    @date.strftime("%a, %-d %b %Y %H:%M:%S %z")
  end

  def rendered_body
    RDiscount.new(@body).to_html
  end

  def to_liquid
    self
  end

  def mp3_path
    "/audio/#{padded_episode_number}.mp3"
  end

  def episode_path
    "/episodes/#{padded_episode_number}.html"
  end

  def length_megabytes
    (@length.to_f / 1024**2).ceil
  end

  def padded_episode_number
    "%05d" % @number
  end
end

def load_episodes(episode_parent_dir)
  paths = episode_parent_dir.entries.select{|path| path.to_s[/^\d+$/] }
  paths.map{|path| parse_episode(episode_parent_dir.join(path))}
end

def parse_episode(path)
  raw = File.read(path.join("#{path.basename}.md"))
  _, raw_headers, raw_body = raw.split(/^---$/)

  headers = parse_headers(raw_headers)
  body    = remove_leading_newlines(raw_body)
  Episode.new(headers, body)
end

def parse_headers(raw)
  headers = {}
  lines = remove_leading_newlines(raw).split("\n")

  lines.each do |line|
    key, value = line.split(/:\s+/)
    headers[key.to_sym] = value
  end

  # Parse the date to a DateTime object.
  headers[:date] = DateTime.parse(headers[:date])

  headers
end

def remove_leading_newlines(str)
  str.sub(/\A\n+/, '')
end

def render_template_in_layout(filename, context)
  content = render_template(filename, context)
  render_content_in_layout(content)
end

def render_content_in_layout(content)
  layout_context = {}
  layout_context[:content]         = content
  layout_context[:head_content]    = render_template("_head.html")
  layout_context[:header_content]  = render_template("_header.html")
  layout_context[:footer_content]  = render_template("_footer.html")

  render_template("layout.html", layout_context)
end

def render_template(filename, context={})
  template     = Liquid::Template.parse(File.read("templates/#{filename}.liquid"), :error_mode => :strict)

  # Turn any non-string keys into string keys.
  stringified_context = {}
  context.each do |key, value|
    stringified_context[key.to_s] = value
  end

  # Make sure every template has access to config.
  stringified_context['config'] = load_config

  template.render!(stringified_context,  { strict_variables: true })
end

def write_file(filename, content)
  File.open("build/#{filename}", 'w+') do |f|
    f.write content
  end
end

def load_config
  YAML.load(File.read('config/website.yml'))
end

def load_secrets
  YAML.load(File.read('config/secrets.yml'))
end

def render_episodes(episodes)
  # Render each episode and store in a hash with their corresponding episode
  # numbers
  rendered_episodes = episodes.inject({}) { |hash, episode|
    hash[episode.padded_episode_number] = render_template("episode.html", episode: episode)
    hash
  }

  # Render and write the episodes page.
  content = render_template_in_layout("episodes.html", rendered_episodes: rendered_episodes.values)
  write_file('episodes.html', content)

  # Make sure the episodes directory exists.
  FileUtils.mkdir_p('build/episodes')

  # Render each individual episode page.
  rendered_episodes.each do |episode_number, rendered_episode|
    content = render_content_in_layout(rendered_episode)
    write_file("episodes/#{episode_number}.html", content)
  end
end

def render_index(latest_episode)
  rendered_episode = render_template("episode.html", episode: latest_episode)
  content = render_template_in_layout("index.html", rendered_episode: rendered_episode)

  write_file('index.html', content)
end

def render_rss(episodes)
  content = render_template("rss.xml", episodes: episodes, secrets: load_secrets)

  write_file('rss.xml', content)
end

def render_pages
  directory = Pathname.new('pages')
  paths = directory.entries.select{|path| path.to_s[/\.md$/] }

  paths.each do |path|
    render_page(directory.join(path))
  end
end

def render_page(path)
  output_filename = "#{path.basename(path.extname)}.html"

  page_content = RDiscount.new(File.read(path)).to_html
  content      = render_template_in_layout('page.html', content: page_content)

  write_file(output_filename, content)
end

def copy_assets
  FileUtils.rm_rf('build/assets')
  FileUtils.cp_r('assets', 'build/assets')
end

episode_parent_dir = Pathname.new('episodes')
episodes = load_episodes(episode_parent_dir).reverse # Newest first.

render_index(episodes.first)
render_episodes(episodes)
render_rss(episodes)
render_pages
copy_assets